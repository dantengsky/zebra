// synthesis VERILOG_INPUT_VERSION SYSTEMVERILOG_2009
// Testbench for autogenerated cmt_top_pl module.
// (C) 2015 Riad S. Wahby <rsw@cs.nyu.edu>

// this will define the cmt_top module as well as
// CMT_TOP_PL_INWIDTH and CMT_TOP_PL_OUTWIDTH macros
`include "simulator.v"
`include "field_arith_defs.v"
`include "verifier_interface_defs.v"
`include "cmt_top_pl.sv"

module cmt_top_pl_test ();

// how many computations should we send through the pipeline?
`ifndef CMT_TOP_PL_NCOMPS
localparam ncomps = 1;
`else
localparam ncomps = `CMT_TOP_PL_NCOMPS;
`endif

// counter: number of pipelined computations
localparam ncbits = $clog2(ncomps + 1);
reg [ncbits-1:0] count_reg, count_next;

reg clk, rstb, trig;
reg en_reg, en_next;
reg new_reg, new_next;
reg [31:0] id;
reg [`F_NBITS-1:0] comp_in [`CMT_TOP_PL_INWIDTH-1:0];
reg [`CMT_TOP_PL_NMUXSELS-1:0] mux_sel;

wire [31:0] id_out;
wire [`F_NBITS-1:0] comp_out [`CMT_TOP_PL_OUTWIDTH-1:0];
wire comp_done, ready_pulse, ready, idle;

wire en_detect = (ready_pulse & ~idle) | trig;

// instance of toplevel - includes all
// prover layers, verifier intfs, and computation layers
cmt_top_pl itop
    ( .clk                  (clk)
    , .rstb                 (rstb)
    , .en                   (en_reg)
    , .comp_new             (new_reg)
    , .comp_done            (comp_done)
    , .id_in                (id)
    , .comp_in              (comp_in)
    , .mux_sel              (mux_sel)
    , .id_out               (id_out)
    , .comp_out             (comp_out)
    , .ready_pulse          (ready_pulse)
    , .ready                (ready)
    , .idle                 (idle)
    );

initial begin
`ifdef SIMULATOR_IS_IUS
    $shm_open("cmt_top_pl_test.shm");
    $shm_probe("ASCM");
`else
    $dumpfile("cmt_top_pl_test.fst");
    $dumpvars;
`endif
end

initial begin
    trig = 0;
    clk = 0;
    rstb = 0;
    $cmt_request(0, `CMT_MUXSEL, mux_sel, `CMT_TOP_PL_NMUXSELS);
    #1 clk = 1;
    #1 rstb = 1;
    #2 trig = 1;
    #2 trig = 0;
end

enum { ST_IDLE, ST_GETID, ST_GETINPUT, ST_START } state_reg, state_next;

`ALWAYS_COMB begin
    count_next = count_reg;
    en_next = 0;
    new_next = new_reg;
    state_next = state_reg;

    case (state_reg)
        ST_IDLE: begin
            if (en_detect) begin
                if (count_reg < ncomps) begin
                    count_next = count_reg + 1;
                    state_next = ST_GETID;
                    new_next = 1;
                end else begin
                    new_next = 0;
                    state_next = ST_START;
                end
            end
        end

        ST_GETID: begin
            state_next = ST_GETINPUT;
        end

        ST_GETINPUT: begin
            state_next = ST_IDLE;
            en_next = 1;
        end

        ST_START: begin
            state_next = ST_IDLE;
            en_next = 1;
        end
    endcase
end

localparam nlayers = `CMT_TOP_PL_NLAYERS + 1;
integer i;
`ALWAYS_FF @(posedge clk or negedge rstb) begin
    if (~rstb) begin
        count_reg <= 0;
        en_reg <= 0;
        new_reg <= 0;
        state_reg <= ST_IDLE;
        id <= 0;
        for (i = 0; i < `CMT_TOP_PL_INWIDTH; i = i + 1) begin
            comp_in[i] <= 0;
        end
    end else begin
        case (state_reg)
            ST_IDLE: begin
                if (ready_pulse & comp_done) begin
                    $cmt_send(id_out, `CMT_OUTPUT, comp_out, `CMT_TOP_PL_OUTWIDTH);
                end

                if (ready_pulse & idle) begin
                    #2 $finish;
                end
            end

            ST_GETID: begin
                id <= $cmt_init(`CMT_TOP_PL_MAXWIDTH, nlayers);
            end

            ST_GETINPUT: begin
                $cmt_request(id, `CMT_INPUT, comp_in, `CMT_TOP_PL_INWIDTH);
            end
        endcase
        count_reg <= count_next;
        en_reg <= en_next;
        new_reg <= new_next;
        state_reg <= state_next;
    end
end

`ALWAYS_FF @(clk) begin
    clk <= #1 ~clk;
end

endmodule
