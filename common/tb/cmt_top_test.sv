// synthesis VERILOG_INPUT_VERSION SYSTEMVERILOG_2009
// Testbench for autogenerated cmt_top module.
// (C) 2015 Riad S. Wahby <rsw@cs.nyu.edu>

// this will define the cmt_top module as well as
// CMT_TOP_INWIDTH and CMT_TOP_OUTWIDTH macros
`include "simulator.v"
`include "field_arith_defs.v"
`include "verifier_interface_defs.v"
`include "cmt_top.sv"

module cmt_top_test ();

reg clk, rstb, en_comp, en_sumchk;
reg [31:0] id;
reg [`F_NBITS-1:0] comp_in [`CMT_TOP_INWIDTH-1:0];
reg [`CMT_TOP_NMUXSELS-1:0] mux_sel;

wire [`F_NBITS-1:0] comp_out [`CMT_TOP_OUTWIDTH-1:0];
wire comp_ready_pulse, comp_ready;
wire sumchk_ready_pulse, sumchk_ready;

// instance of toplevel - includes all
// prover layers, verifier intfs, and computation layers
cmt_top itop
    ( .clk                  (clk)
    , .rstb                 (rstb)
    , .id                   (id)
    , .mux_sel              (mux_sel)
    , .en_comp              (en_comp)
    , .comp_in              (comp_in)
    , .comp_ready_pulse     (comp_ready_pulse)
    , .comp_ready           (comp_ready)
    , .comp_out             (comp_out)
    , .en_sumchk            (en_sumchk)
    , .sumchk_ready_pulse   (sumchk_ready_pulse)
    , .sumchk_ready         (sumchk_ready)
    );

localparam nlayers = `CMT_TOP_NLAYERS + 1;
integer i;
initial begin
`ifdef SIMULATOR_IS_ICARUS
    $dumpfile ("cmt_top_test.fst");
    $dumpvars;
`else
    $shm_open("cmt_top_test.shm");
    $shm_probe("ASCM");
`endif
    for (i = 0; i < `CMT_TOP_INWIDTH; i = i + 1) begin
        comp_in[i] = 0;
    end
    id = 0;
    clk = 0;
    rstb = 0;
    en_comp = 0;
    en_sumchk = 0;
    $cmt_request(0, `CMT_MUXSEL, mux_sel, `CMT_TOP_NMUXSELS);
    #1 rstb = 1;
    clk = 1;
    id = $cmt_init(`CMT_TOP_MAXWIDTH, nlayers);
    $cmt_request(id, `CMT_INPUT, comp_in, `CMT_TOP_INWIDTH);
    #3 en_comp = 1;
    #2 en_comp = 0;
end

`ALWAYS_FF @(posedge clk) begin
    if (comp_ready_pulse) begin
        $cmt_send(id, `CMT_OUTPUT, comp_out, `CMT_TOP_OUTWIDTH);
        en_sumchk <= 1;
    end else if (sumchk_ready_pulse) begin
        #2 $finish;
    end else begin
        en_sumchk <= 0;
    end
end

`ALWAYS_FF @(clk) begin
    clk <= #1 ~clk;
end

endmodule
